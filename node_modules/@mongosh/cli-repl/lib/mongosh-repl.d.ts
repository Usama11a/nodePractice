/// <reference types="node" />
import type { AutoEncryptionOptions, ServiceProvider } from '@mongosh/service-provider-core';
import { EvaluationListener, OnLoadResult, ShellCliOptions, ShellInternalState } from '@mongosh/shell-api';
import { ShellEvaluator, ShellResult } from '@mongosh/shell-evaluator';
import { CliUserConfig, ConfigProvider, MongoshBus } from '@mongosh/types';
import { ReplOptions, REPLServer } from 'repl';
import { Readable, Writable } from 'stream';
import * as asyncRepl from './async-repl';
import { StyleDefinition } from './clr';
import { LineByLineInput } from './line-by-line-input';
export declare type MongoshCliOptions = ShellCliOptions & {
    redactInfo?: boolean;
    quiet?: boolean;
};
export declare type MongoshIOProvider = Omit<ConfigProvider<CliUserConfig>, 'validateConfig'> & {
    getHistoryFilePath(): string;
    exit(code: number): Promise<never>;
    readFileUTF8(filename: string): Promise<{
        contents: string;
        absolutePath: string;
    }>;
    startMongocryptd(): Promise<AutoEncryptionOptions['extraOptions']>;
};
export declare type MongoshNodeReplOptions = {
    input: Readable;
    output: Writable;
    bus: MongoshBus;
    ioProvider: MongoshIOProvider;
    shellCliOptions?: Partial<MongoshCliOptions>;
    nodeReplOptions?: Partial<ReplOptions>;
};
export declare type InitializationToken = {
    __initialized: 'yes';
};
declare type MongoshRuntimeState = {
    shellEvaluator: ShellEvaluator;
    internalState: ShellInternalState;
    repl: REPLServer;
    console: Console;
};
declare class MongoshNodeRepl implements EvaluationListener {
    _runtimeState: MongoshRuntimeState | null;
    input: Readable;
    lineByLineInput: LineByLineInput;
    output: Writable;
    bus: MongoshBus;
    nodeReplOptions: Partial<ReplOptions>;
    shellCliOptions: Partial<MongoshCliOptions>;
    ioProvider: MongoshIOProvider;
    onClearCommand?: EvaluationListener['onClearCommand'];
    insideAutoCompleteOrGetPrompt: boolean;
    inspectCompact: number | boolean;
    inspectDepth: number;
    started: boolean;
    showStackTraces: boolean;
    loadNestingLevel: number;
    constructor(options: MongoshNodeReplOptions);
    setIsInteractive(value: boolean): void;
    initialize(serviceProvider: ServiceProvider): Promise<InitializationToken>;
    startRepl(_initializationToken: InitializationToken): Promise<void>;
    greet(mongodVersion: string): Promise<void>;
    printStartupLog(internalState: ShellInternalState): Promise<void>;
    eval(originalEval: asyncRepl.OriginalEvalFunction, input: string, context: any, filename: string): Promise<any>;
    onLoad(filename: string): Promise<OnLoadResult>;
    loadExternalFile(filename: string): Promise<void>;
    loadExternalCode(code: string, filename: string): Promise<ShellResult>;
    onAsyncSigint(): Promise<boolean>;
    writer(result: any): string;
    onPrint(values: ShellResult[]): void;
    onPrompt(question: string, type: 'password'): Promise<string>;
    formatOutput(value: {
        value: any;
        type?: string;
    }): string;
    formatError(value: Error): string;
    clr(text: string, style: StyleDefinition): string;
    getFormatOptions(): {
        colors: boolean;
        compact: number | boolean;
        depth: number;
        showStackTraces: boolean;
    };
    runtimeState(): MongoshRuntimeState;
    close(): Promise<void>;
    onExit(): Promise<never>;
    getConfig<K extends keyof CliUserConfig>(key: K): Promise<CliUserConfig[K]>;
    setConfig<K extends keyof CliUserConfig>(key: K, value: CliUserConfig[K]): Promise<'success' | 'ignored'>;
    validateConfig<K extends keyof CliUserConfig>(key: K, value: CliUserConfig[K]): Promise<string | null>;
    listConfigOptions(): Promise<string[]> | string[];
    startMongocryptd(): Promise<AutoEncryptionOptions['extraOptions']>;
    private getShellPrompt;
}
export default MongoshNodeRepl;
