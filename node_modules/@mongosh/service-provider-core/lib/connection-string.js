"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionString = void 0;
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("@mongosh/errors");
const whatwg_url_1 = require("./whatwg-url");
const DUMMY_HOSTNAME = '__this_is_a_placeholder__';
const HOSTS_REGEX = new RegExp(String.raw `(?<protocol>mongodb(?:\+srv|)):\/\/(?:(?<username>[^:]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^\/?@]+)(?<rest>.*)`);
const caseInsenstiveURLSearchParams = (Ctor) => class CaseInsenstiveURLSearchParams extends Ctor {
    append(name, value) {
        return super.append(this._normalizeKey(name), value);
    }
    delete(name) {
        return super.delete(this._normalizeKey(name));
    }
    get(name) {
        return super.get(this._normalizeKey(name));
    }
    getAll(name) {
        return super.getAll(this._normalizeKey(name));
    }
    has(name) {
        return super.has(this._normalizeKey(name));
    }
    set(name, value) {
        return super.set(this._normalizeKey(name), value);
    }
    _normalizeKey(name) {
        name = `${name}`;
        for (const key of this.keys()) {
            if (key.toLowerCase() === name.toLowerCase()) {
                name = key;
                break;
            }
        }
        return name;
    }
};
class URLWithoutHost extends whatwg_url_1.URL {
}
class ConnectionString extends URLWithoutHost {
    constructor(uri) {
        var _a;
        const match = uri.match(HOSTS_REGEX);
        if (!match) {
            throw new errors_1.MongoshInvalidInputError(`Invalid connection string "${uri}"`, errors_1.CommonErrors.InvalidArgument);
        }
        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
        assert_1.default(protocol);
        assert_1.default(hosts);
        try {
            decodeURIComponent(username !== null && username !== void 0 ? username : '');
            decodeURIComponent(password !== null && password !== void 0 ? password : '');
        }
        catch (err) {
            throw new errors_1.MongoshInvalidInputError(err.message, errors_1.CommonErrors.InvalidArgument);
        }
        const illegalCharacters = new RegExp(String.raw `[:/?#\[\]@]`, 'gi');
        if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
            throw new errors_1.MongoshInvalidInputError(`Username contains unescaped characters ${username}`, errors_1.CommonErrors.InvalidArgument);
        }
        if (!username || !password) {
            const uriWithoutProtocol = uri.replace(`${protocol}://`, '');
            if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {
                throw new errors_1.MongoshInvalidInputError('URI contained empty userinfo section', errors_1.CommonErrors.InvalidArgument);
            }
        }
        if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
            throw new errors_1.MongoshInvalidInputError('Password contains unescaped characters', errors_1.CommonErrors.InvalidArgument);
        }
        let authString = '';
        if (typeof username === 'string')
            authString += username;
        if (typeof password === 'string')
            authString += `:${password}`;
        if (authString)
            authString += '@';
        super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
        this._hosts = hosts.split(',');
        if (this.isSRV && this.hosts.length !== 1) {
            throw new errors_1.MongoshInvalidInputError('mongodb+srv URI cannot have multiple service names', errors_1.CommonErrors.InvalidArgument);
        }
        if (this.isSRV && this.hosts.some(host => host.includes(':'))) {
            throw new errors_1.MongoshInvalidInputError('mongodb+srv URI cannot have port number', errors_1.CommonErrors.InvalidArgument);
        }
        if (!this.pathname) {
            this.pathname = '/';
        }
        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
    }
    get host() { return DUMMY_HOSTNAME; }
    set host(_ignored) { throw new errors_1.MongoshInternalError('No single host for connection string'); }
    get hostname() { return DUMMY_HOSTNAME; }
    set hostname(_ignored) { throw new errors_1.MongoshInternalError('No single host for connection string'); }
    get port() { return ''; }
    set port(_ignored) { throw new errors_1.MongoshInternalError('No single host for connection string'); }
    get href() { return this.toString(); }
    set href(_ignored) { throw new errors_1.MongoshInternalError('Cannot set href for connection strings'); }
    get isSRV() {
        return this.protocol.includes('srv');
    }
    get hosts() {
        return this._hosts;
    }
    set hosts(list) {
        this._hosts = list;
    }
    toString() {
        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(','));
    }
    clone() {
        return new ConnectionString(this.toString());
    }
}
exports.ConnectionString = ConnectionString;
//# sourceMappingURL=connection-string.js.map