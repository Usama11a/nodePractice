"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkInterrupted = exports.InterruptFlag = exports.MongoshInterruptedError = void 0;
const errors_1 = require("@mongosh/errors");
const kUncatchable = Symbol.for('@@mongosh.uncatchable');
class MongoshInterruptedError extends errors_1.MongoshBaseError {
    constructor() {
        super('MongoshInterruptedError', 'execution was interrupted');
        this[_a] = true;
    }
}
exports.MongoshInterruptedError = MongoshInterruptedError;
_a = kUncatchable;
class InterruptFlag {
    constructor() {
        this.interrupted = false;
        this.deferred = this.defer();
    }
    isSet() {
        return this.interrupted;
    }
    asPromise() {
        return this.deferred.promise;
    }
    set() {
        this.interrupted = true;
        this.deferred.reject(new MongoshInterruptedError());
    }
    reset() {
        this.interrupted = false;
        this.deferred = this.defer();
    }
    defer() {
        const result = {};
        result.promise = new Promise((_, reject) => {
            result.reject = reject;
        });
        result.promise.catch(() => {
        });
        return result;
    }
}
exports.InterruptFlag = InterruptFlag;
function checkInterrupted(internalState) {
    var _b;
    if ((_b = internalState === null || internalState === void 0 ? void 0 : internalState.interrupted) === null || _b === void 0 ? void 0 : _b.isSet()) {
        throw new MongoshInterruptedError();
    }
    return internalState === null || internalState === void 0 ? void 0 : internalState.interrupted;
}
exports.checkInterrupted = checkInterrupted;
//# sourceMappingURL=interruptor.js.map