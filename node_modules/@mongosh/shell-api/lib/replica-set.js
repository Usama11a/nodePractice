"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const helpers_1 = require("./helpers");
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
let ReplicaSet = class ReplicaSet extends decorators_1.ShellApiWithMongoClass {
    constructor(database) {
        super();
        this._database = database;
    }
    get _mongo() {
        return this._database._mongo;
    }
    async initiate(config = {}) {
        this._emitReplicaSetApiCall('initiate', { config });
        return this._database._runAdminCommand({ replSetInitiate: config });
    }
    async _getConfig() {
        try {
            const result = await this._database._runAdminCommand({ replSetGetConfig: 1 });
            if (result.config === undefined) {
                throw new errors_1.MongoshRuntimeError('Documented returned from command replSetGetConfig does not contain \'config\'', errors_1.CommonErrors.CommandFailed);
            }
            return result.config;
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                const doc = await this._database.getSiblingDB('local').getCollection('system.replset').findOne();
                if (doc === null) {
                    throw new errors_1.MongoshRuntimeError('No documents in local.system.replset', errors_1.CommonErrors.CommandFailed);
                }
                return doc;
            }
            throw error;
        }
    }
    async config() {
        this._emitReplicaSetApiCall('config', {});
        return this._getConfig();
    }
    async conf() {
        this._emitReplicaSetApiCall('conf', {});
        return this._getConfig();
    }
    async reconfig(config, options = {}) {
        var _a;
        helpers_1.assertArgsDefinedType([config, options], ['object', [undefined, 'object']], 'ReplicaSet.reconfig');
        this._emitReplicaSetApiCall('reconfig', { config, options });
        const conf = await this._getConfig();
        config.version = conf.version ? conf.version + 1 : 1;
        (_a = config.protocolVersion) !== null && _a !== void 0 ? _a : (config.protocolVersion = conf.protocolVersion);
        const cmd = { replSetReconfig: config, ...options };
        return this._database._runAdminCommand(cmd);
    }
    async reconfigForPSASet(newMemberIndex, config, options = {}) {
        var _a;
        helpers_1.assertArgsDefinedType([newMemberIndex, config, options], ['number', 'object', [undefined, 'object']], 'ReplicaSet.reconfigForPSASet');
        this._emitReplicaSetApiCall('reconfigForPSASet', { newMemberIndex, config, options });
        const print = (msg) => this._internalState.shellApi.print(msg);
        const sleep = (duration) => this._internalState.shellApi.sleep(duration);
        const newMemberConfig = (_a = config.members) === null || _a === void 0 ? void 0 : _a[newMemberIndex];
        if (!newMemberConfig) {
            throw new errors_1.MongoshInvalidInputError(`Node at index ${newMemberIndex} does not exist in the new config`, errors_1.CommonErrors.InvalidArgument);
        }
        if (newMemberConfig.votes !== 1) {
            throw new errors_1.MongoshInvalidInputError(`Node at index ${newMemberIndex} must have { votes: 1 } in the new config (actual: { votes: ${newMemberConfig.votes} })`, errors_1.CommonErrors.InvalidArgument);
        }
        const oldConfig = await this._getConfig();
        const oldMemberConfig = oldConfig.members.find(member => member._id === newMemberConfig._id);
        if (!oldMemberConfig) {
            if (oldConfig.members.find(member => member.host === newMemberConfig.host)) {
                await print(`Warning: Node at index ${newMemberIndex} has { host: "${newMemberConfig.host}" }, ` +
                    'which is also present in the old config, but with a different _id field.');
            }
        }
        else if (oldMemberConfig.votes) {
            throw new errors_1.MongoshInvalidInputError(`Node at index ${newMemberIndex} must have { votes: 0 } in the old config (actual: { votes: ${oldMemberConfig.votes} })`, errors_1.CommonErrors.InvalidArgument);
        }
        const newMemberPriority = newMemberConfig.priority;
        await print(`Running first reconfig to give member at index ${newMemberIndex} { votes: 1, priority: 0 }`);
        newMemberConfig.votes = 1;
        newMemberConfig.priority = 0;
        const firstResult = await this.reconfig(config, options);
        if (newMemberPriority === 0) {
            await print('No second reconfig necessary because .priority = 0');
            return firstResult;
        }
        await print(`Running second reconfig to give member at index ${newMemberIndex} { priority: ${newMemberPriority} }`);
        newMemberConfig.priority = newMemberPriority;
        let result = ['success', {}];
        let sleepInterval = 1000;
        for (let i = 0; i < 12; i++) {
            try {
                if (result[0] === 'error') {
                    await sleep(sleepInterval);
                    sleepInterval *= 1.3;
                    if (sleepInterval > 2500) {
                        await print('Second reconfig did not succeed yet, starting new attempt...');
                    }
                }
                result = ['success', await this.reconfig(config, options)];
                break;
            }
            catch (err) {
                result = ['error', err];
            }
        }
        if (result[0] === 'error') {
            await print('Second reconfig did not succeed, giving up');
            await print(`Attempted command: rs.reconfig(${JSON.stringify(config, null, '  ')}, ${JSON.stringify(options)})`);
            throw result[1];
        }
        return result[1];
    }
    async status() {
        this._emitReplicaSetApiCall('status', {});
        return this._database._runAdminCommand({
            replSetGetStatus: 1,
        });
    }
    async isMaster() {
        this._emitReplicaSetApiCall('isMaster', {});
        return this._database._runAdminCommand({
            isMaster: 1,
        });
    }
    async printSecondaryReplicationInfo() {
        this._emitReplicaSetApiCall('printSecondaryReplicationInfo', {});
        return this._database.printSecondaryReplicationInfo();
    }
    async printSlaveReplicationInfo() {
        throw new errors_1.MongoshDeprecatedError('printSlaveReplicationInfo has been deprecated. Use printSecondaryReplicationInfo instead');
    }
    async printReplicationInfo() {
        this._emitReplicaSetApiCall('printReplicationInfo', {});
        return this._database.printReplicationInfo();
    }
    async add(hostport, arb) {
        helpers_1.assertArgsDefinedType([hostport, arb], [['string', 'object'], [undefined, 'boolean']], 'ReplicaSet.add');
        this._emitReplicaSetApiCall('add', { hostport, arb });
        const configDoc = await this._getConfig();
        configDoc.version++;
        const max = Math.max(...configDoc.members.map(m => m._id));
        let cfg;
        if (typeof hostport === 'string') {
            cfg = { _id: max + 1, host: hostport };
            if (arb) {
                cfg.arbiterOnly = true;
            }
        }
        else if (arb === true) {
            throw new errors_1.MongoshInvalidInputError(`Expected first parameter to be a host-and-port string of arbiter, but got ${JSON.stringify(hostport)}`, errors_1.CommonErrors.InvalidArgument);
        }
        else {
            cfg = hostport;
            if (cfg._id === null || cfg._id === undefined) {
                cfg._id = max + 1;
            }
        }
        configDoc.members.push(cfg);
        return this._database._runAdminCommand({
            replSetReconfig: configDoc,
        });
    }
    async addArb(hostname) {
        this._emitReplicaSetApiCall('addArb', { hostname });
        return this.add(hostname, true);
    }
    async remove(hostname) {
        helpers_1.assertArgsDefinedType([hostname], ['string'], 'ReplicaSet.remove');
        this._emitReplicaSetApiCall('remove', { hostname });
        const configDoc = await this._getConfig();
        configDoc.version++;
        for (let i = 0; i < configDoc.members.length; i++) {
            if (configDoc.members[i].host === hostname) {
                configDoc.members.splice(i, 1);
                return this._database._runAdminCommand({
                    replSetReconfig: configDoc,
                });
            }
        }
        throw new errors_1.MongoshInvalidInputError(`Couldn't find ${hostname} in ${JSON.stringify(configDoc.members)}. Is ${hostname} a member of this replset?`, errors_1.CommonErrors.InvalidArgument);
    }
    async freeze(secs) {
        helpers_1.assertArgsDefinedType([secs], ['number'], 'ReplicaSet.freeze');
        this._emitReplicaSetApiCall('freeze', { secs });
        return this._database._runAdminCommand({
            replSetFreeze: secs,
        });
    }
    async stepDown(stepdownSecs, catchUpSecs) {
        helpers_1.assertArgsDefinedType([stepdownSecs, catchUpSecs], [[undefined, 'number'], [undefined, 'number']], 'ReplicaSet.stepDown');
        this._emitReplicaSetApiCall('stepDown', { stepdownSecs, catchUpSecs });
        const cmd = {
            replSetStepDown: stepdownSecs === undefined ? 60 : stepdownSecs,
        };
        if (catchUpSecs !== undefined) {
            cmd.secondaryCatchUpPeriodSecs = catchUpSecs;
        }
        return this._database._runAdminCommand(cmd);
    }
    async syncFrom(host) {
        helpers_1.assertArgsDefinedType([host], ['string'], 'ReplicaSet.syncFrom');
        this._emitReplicaSetApiCall('syncFrom', { host });
        return this._database._runAdminCommand({
            replSetSyncFrom: host,
        });
    }
    [enums_1.asPrintable]() {
        return `ReplicaSet class connected to ${history_1.redactCredentials(this._database._mongo._uri)} via db ${this._database._name}`;
    }
    _emitReplicaSetApiCall(methodName, methodArguments = {}) {
        this._database._mongo._internalState.emitApiCall({
            method: methodName,
            class: 'ReplicaSet',
            arguments: methodArguments
        });
    }
};
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "initiate", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "config", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "conf", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "reconfig", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "reconfigForPSASet", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "status", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "isMaster", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "printSecondaryReplicationInfo", null);
__decorate([
    decorators_1.deprecated,
    decorators_1.returnsPromise
], ReplicaSet.prototype, "printSlaveReplicationInfo", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "printReplicationInfo", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "add", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "addArb", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "remove", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "freeze", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "stepDown", null);
__decorate([
    decorators_1.returnsPromise
], ReplicaSet.prototype, "syncFrom", null);
ReplicaSet = __decorate([
    decorators_1.shellApiClassDefault
], ReplicaSet);
exports.default = ReplicaSet;
//# sourceMappingURL=replica-set.js.map