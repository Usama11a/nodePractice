"use strict";
const whatwg_url_1 = require("whatwg-url");
class MongoParseError extends Error {
}
function matchesParentDomain(srvAddress, parentDomain) {
    const regex = /^.*?\./;
    const srv = `.${srvAddress.replace(regex, '')}`;
    const parent = `.${parentDomain.replace(regex, '')}`;
    return srv.endsWith(parent);
}
async function resolveMongodbSrv(input, options) {
    var _a;
    const dns = (_a = options === null || options === void 0 ? void 0 : options.dns) !== null && _a !== void 0 ? _a : require('dns');
    if (input.startsWith('mongodb://')) {
        return input;
    }
    if (!input.startsWith('mongodb+srv://')) {
        throw new MongoParseError('Unknown URL scheme');
    }
    const url = new whatwg_url_1.URL(input);
    if (url.port) {
        throw new Error('mongodb+srv:// URL cannot have port number');
    }
    const lookupAddress = url.hostname;
    const [srvResult, txtResult] = await Promise.all([
        (async () => {
            const addresses = await new Promise((resolve, reject) => {
                dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
                    if (err)
                        return reject(err);
                    return resolve(addresses);
                });
            });
            if (addresses.length === 0) {
                throw new MongoParseError('No addresses found at host');
            }
            for (const { name } of addresses) {
                if (!matchesParentDomain(name, lookupAddress)) {
                    throw new MongoParseError('Server record does not share hostname with parent URI');
                }
            }
            return addresses.map(r => { var _a; return r.name + (((_a = r.port) !== null && _a !== void 0 ? _a : 27017) === 27017 ? '' : `:${r.port}`); });
        })(),
        (async () => {
            var _a, _b;
            const txtRecord = await new Promise((resolve, reject) => {
                dns.resolveTxt(lookupAddress, (err, record) => {
                    var _a, _b;
                    if (err) {
                        if (err.code && (err.code !== 'ENODATA' && err.code !== 'ENOTFOUND')) {
                            reject(err);
                        }
                        else {
                            resolve('');
                        }
                    }
                    else {
                        if (record.length > 1) {
                            reject(new MongoParseError('Multiple text records not allowed'));
                        }
                        else {
                            resolve((_b = (_a = record[0]) === null || _a === void 0 ? void 0 : _a.join('')) !== null && _b !== void 0 ? _b : '');
                        }
                    }
                });
            });
            const txtRecordOptions = new whatwg_url_1.URLSearchParams(txtRecord);
            const txtRecordOptionKeys = [...txtRecordOptions.keys()];
            if (txtRecordOptionKeys.some(key => key !== 'authSource' && key !== 'replicaSet')) {
                throw new MongoParseError('Text record must only set `authSource` or `replicaSet`');
            }
            const source = (_a = txtRecordOptions.get('authSource')) !== null && _a !== void 0 ? _a : undefined;
            const replicaSet = (_b = txtRecordOptions.get('replicaSet')) !== null && _b !== void 0 ? _b : undefined;
            if (source === '' || replicaSet === '') {
                throw new MongoParseError('Cannot have empty URI params in DNS TXT Record');
            }
            return txtRecordOptions;
        })()
    ]);
    url.protocol = 'mongodb:';
    url.hostname = '__DUMMY_HOSTNAME__';
    if (!url.pathname) {
        url.pathname = '/';
    }
    for (const [key, value] of txtResult) {
        if (!url.searchParams.has(key)) {
            url.searchParams.set(key, value);
        }
    }
    if (!url.searchParams.has('tls') && !url.searchParams.has('ssl')) {
        url.searchParams.set('tls', 'true');
    }
    return url.toString().replace('__DUMMY_HOSTNAME__', srvResult.join(','));
}
module.exports = resolveMongodbSrv;
//# sourceMappingURL=index.js.map